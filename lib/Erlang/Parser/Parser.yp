# Copyright 2011 Anneli Cuss. ( anneli AT cpan DOT org )
# This is free software; you can redistribute it and/or modify it under the
# same terms as Perl itself.

%nonassoc KW_CATCH
%left KW_ANDALSO KW_ORELSE
%nonassoc EQUALS
%nonassoc EQUALITY NOT_EQUAL LARROW LDARROW LTE GTE LT GT STRICTLY_EQUAL NOT_QUITE_EQUAL
%right SEND
%left KW_OR KW_BOR KW_BXOR
%left KW_BSL KW_BSR KW_AND KW_BAND
%left ADD SUBTRACT
%left DIVIDE KW_DIV MULTIPLY KW_REM
%left NEG
%right KW_NOT
%right LISTADD LISTSUBTRACT

%{
    use Erlang::Parser::Node::Directive;
    use Erlang::Parser::Node::DefList;
    use Erlang::Parser::Node::Def;
    use Erlang::Parser::Node::WhenList;

    sub new_node {
	my ($kind, @args) = @_;
	do {
	    no strict 'refs';
	    my $class = "Erlang::Parser::Node::$kind";
	    &{"${class}::new"}($class, @args)
	}
    }
%}

%%

# TODO: A few of these lists are flawed in that their optional type isn't done correctly
# (they allow constructs like [, 1, 2]). Fix this.

root:
				{ [] }
    | root rootstmt		{ [@{$_[1]}, $_[2]] }
    ;

rootstmt:
      SUBTRACT ATOM LPAREN exprlist RPAREN PERIOD	{ new_node 'Directive', $_[2], $_[4] }
    | deflist PERIOD					{ $_[1] }
    ;

deflist:
      def			{ new_node('DefList')->_append($_[1]) }
    | deflist SEMICOLON def	{ $_[1]->_append($_[3]) }
    ;

def:
      ATOM LPAREN exprlist RPAREN whenlist RARROW stmtlist	{ new_node 'Def', $_[1], $_[3], $_[5]->group, $_[7] }
    ;

whenlist:
				{ new_node 'WhenList' }
    | KW_WHEN expr		{ new_node('WhenList')->append($_[2]) }
    # TODO differentiate these. (a;b,c (A)||(B&&C))
    | whenlist COMMA expr	{ $_[1]->_append($_[3]) }
    | whenlist SEMICOLON expr	{ $_[1]->_group->_append($_[3]) }
    ;

# somehow this is an idiom. exprlist = 0 or more. stmtlist = 1 or more.
exprlist:
				{ [] }
    | stmtlist 			{ $_[1] }
    ;

stmtlist:
      expr			{ [$_[1]] }
    | stmtlist COMMA expr	{ [@{$_[1]}, $_[3]] }
    ;

unparenexpr:
      immexpr
    | case
    | fun
    | binary
    | receive
    | comprehension
    | try
    | if
    | KW_BEGIN exprlist KW_END	{ ['begin', $_[2]] }
    | expr SEND expr		{ ['send', $_[1], $_[3]] }
    | expr LT expr		{ ['lt', $_[1], $_[3]] }
    | expr LTE expr		{ ['lte', $_[1], $_[3]] }
    | expr GT expr		{ ['gt', $_[1], $_[3]] }
    | expr GTE expr		{ ['gte', $_[1], $_[3]] }
    | expr DIVIDE expr		{ ['divide', $_[1], $_[3]] }
    | expr KW_DIV expr		{ ['div', $_[1], $_[3]] }
    | expr MULTIPLY expr	{ ['multiply', $_[1], $_[3]] }
    | expr ADD expr		{ ['add', $_[1], $_[3]] }
    | expr SUBTRACT expr	{ ['subtract', $_[1], $_[3]] }
    | expr EQUALS expr		{ ['equals', $_[1], $_[3]] }
    | expr LISTADD expr		{ ['list-add', $_[1], $_[3]] }
    | expr LISTSUBTRACT expr	{ ['list-subtract', $_[1], $_[3]] }
    | expr EQUALITY expr	{ ['equality', $_[1], $_[3]] }
    | expr STRICTLY_EQUAL expr	{ ['strictly-equal', $_[1], $_[3]] }
    | expr NOT_EQUAL expr	{ ['not-equal', $_[1], $_[3]] }
    | expr NOT_QUITE_EQUAL expr	{ ['not-quite_equal', $_[1], $_[3]] }
    | expr KW_BSL expr		{ ['bsl', $_[1], $_[3]] }
    | expr KW_BSR expr		{ ['bsr', $_[1], $_[3]] }
    | expr KW_BOR expr		{ ['bor', $_[1], $_[3]] }
    | expr KW_BAND expr		{ ['band', $_[1], $_[3]] }
    | expr KW_BXOR expr		{ ['bxor', $_[1], $_[3]] }
    | expr KW_REM expr		{ ['rem', $_[1], $_[3]] }
    | expr KW_ANDALSO expr	{ ['andalso', $_[1], $_[3]] }
    | expr KW_ORELSE expr	{ ['orelse', $_[1], $_[3]] }
    | expr KW_AND expr		{ ['and', $_[1], $_[3]] }
    | expr KW_OR expr		{ ['or', $_[1], $_[3]] }
    | SUBTRACT expr %prec NEG	{ ['neg', $_[2]] }
    | KW_NOT expr		{ ['not', $_[2]] }
    | KW_CATCH expr		{ ['catch-expr', $_[2]] }

    # TODO: unhack this.
    | expr LARROW expr		{ ['larrow', $_[1], $_[3]] }
    | expr LDARROW expr		{ ['ldarrow', $_[1], $_[3]] }

    | call
    ;

parenexpr:
      LPAREN expr RPAREN		{ $_[2] }
    ;

expr:
      unparenexpr
    | parenexpr
    ;

parenorimm:
      parenexpr
    | immexpr
    ;

immexpr:
      ATOM			{ ['atom', $_[1]] }
    | FLOAT			{ ['float', $_[1]] }
    | BASE_INTEGER		{ ['base-integer', $_[1]] }
    | INTEGER			{ ['integer', $_[1]] }
    | string
    | VARIABLE OPENRECORD ATOM  { ['variable-record-access', $_[1], $_[3]] }
    | VARIABLE newrecord	{ ['variable-record-update', $_[1], @{$_[2]}[1..2]] }
    | VARIABLE			{ ['variable', $_[1]] }
    | MACRO			{ ['macro', substr($_[1], 1)] }
    | LITERAL			{ ['literal', substr($_[1], 1)] }
    | list
    | tuple
    | newrecord
    ;

string:
      STRING			{ ['string', $_[1]] }
    | string STRING		{ ['string', $_[1]->[1] . $_[2]] }
    ;

call:
      intcall
    | extcall
    ;

intcall:
      parenorimm LPAREN exprlist RPAREN		{ ['call', undef, $_[1], $_[3]] }
    ;

extcall:
      parenorimm COLON intcall 			{ ['call', $_[1], $_[3]->[2], $_[3]->[3]] }
    ;

list:
      LISTOPEN exprlist listcdr LISTCLOSE	{ ['list', $_[2], $_[3]] }
    ;

# This is not a full node.
listcdr:
						{ undef }
    | PIPE expr					{ $_[2] }
    ;

comprehension:
      LISTOPEN expr COMPREHENSION exprlist LISTCLOSE		{ ['comprehension', $_[2], $_[4]] }
    | OPENBINARY binary COMPREHENSION exprlist CLOSEBINARY	{ ['binary-comprehension', $_[2], $_[4]] }
    ;

tuple:
      TUPLEOPEN exprlist TUPLECLOSE	{ ['tuple', $_[2]] }
    ;

case:
      KW_CASE expr KW_OF altlist KW_END	{ ['case', $_[2], $_[4]->[1]] }
    ;

altlist:
      alt			{ ['altlist', [$_[1]]] }
    | altlist SEMICOLON alt	{ ['altlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

alt:
      expr whenlist RARROW stmtlist	{ ['alt', $_[1], $_[2], $_[4]] }
    ;

fun:
      funlocal
    | KW_FUN ATOM COLON ATOM DIVIDE INTEGER				{ ['fun-ext', $_[2], $_[4], $_[6]] }
    | KW_FUN MACRO COLON ATOM DIVIDE INTEGER				{ ['fun-ext-macro', substr($_[2], 1), $_[4], $_[6]] }
    | KW_FUN VARIABLE COLON ATOM DIVIDE INTEGER				{ ['fun-ext-var', $_[2], $_[4], $_[6]] }
    | KW_FUN ATOM DIVIDE INTEGER					{ ['fun-int', $_[2], $_[4]] }
    ;

funlocal:
      KW_FUN funlocallist KW_END					{ ['fun-local', $_[2]] }
    ;
    
# These are not full nodes.
funlocallist:
      funlocalexpr							{ [$_[1]] }
    | funlocallist SEMICOLON funlocalexpr				{ [@{$_[1]}, $_[3]] }
    ;

funlocalexpr:
      LPAREN exprlist RPAREN whenlist RARROW stmtlist 		{ [$_[2], $_[4], $_[6]] }
    ;

newrecord:
      OPENRECORD ATOM TUPLEOPEN exprlist TUPLECLOSE		{ ['record-new', $_[2], $_[4]] }
    ;

binary:
      OPENBINARY optbinarylist CLOSEBINARY			{ ['binary', $_[2]] }
    ;

# These are not full nodes.
optbinarylist:
     								{ [] }
    | binarylist
    ;

binarylist:
      binaryexpr						{ [$_[1]] }
    | binarylist COMMA binaryexpr				{ [@{$_[1]}, $_[3]] }
    ;

binaryexpr:
      parenorimm optbinarysize optbinaryqualifier 		{ ['binaryexpr', $_[1], $_[2], $_[3]] }
    ;

# These are not full nodes.
optbinarysize:
								{ undef }
    | COLON immexpr						{ $_[2] }
    ;

optbinaryqualifier:
								{ undef }
    | DIVIDE binaryqualifier					{ $_[2] }
    ;

binaryqualifier:
      ATOM
    | binaryqualifier SUBTRACT ATOM				{ "$_[1]-$_[3]" }
    ;

receive:
      KW_RECEIVE altlist after KW_END				{ ['receive', $_[2]->[1], $_[3]] }
    ;

# This is not a full node.
after:
								{ undef }
    | KW_AFTER expr RARROW exprlist				{ [$_[2], $_[4]] }
    ;

try:
      KW_TRY exprlist opttryof opttrycatch opttryafter KW_END	{ ['try', $_[2], $_[3], $_[4], $_[5]] }
    ;

# These are not full nodes.
opttryof:
								{ undef }
    | KW_OF altlist						{ $_[2]->[1] }
    ;

opttrycatch:
								{ undef }
    | KW_CATCH catchaltlist					{ $_[2]->[1] }
    ;

opttryafter:
								{ undef }
    | KW_AFTER exprlist 					{ $_[2] }
    ;

catchaltlist:
      catchalt				{ ['catchaltlist', [$_[1]]] }
    | catchaltlist SEMICOLON catchalt	{ ['catchaltlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

catchalt:
      ATOM COLON expr whenlist RARROW stmtlist	{ ['catchalt', $_[1], $_[3], $_[4], $_[6]] }
    | VARIABLE COLON expr whenlist RARROW stmtlist	{ ['catchalt', $_[1], $_[3], $_[4], $_[6]] }
    | expr whenlist RARROW stmtlist		{ ['catchalt', undef, $_[1], $_[2], $_[4]] }
    ;

if:
      KW_IF iflist KW_END			{ ['if', $_[2]] }
    ;

iflist:
      ifexpr			{ [$_[1]] }
    | iflist SEMICOLON ifexpr	{ [@{$_[1]}, $_[3]] }
    ;

ifexpr:
      ifseq RARROW stmtlist	{ [$_[1], $_[3]] }
    ;

ifseq:
      expr		{ [$_[1]] }
    | ifseq COMMA expr	{ [@{$_[1]}, $_[3]] }
    ;
%%

=over 4

=item C<new>

Creates a new parser object. See L<Parse::Yapp> for more information.

=cut

1;

# vim: set sw=4 filetype=perl:
