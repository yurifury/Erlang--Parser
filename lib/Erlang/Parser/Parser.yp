# Copyright 2011 Anneli Cuss. ( anneli AT cpan DOT org )
# This is free software; you can redistribute it and/or modify it under the
# same terms as Perl itself.

%nonassoc EQUALS
%left ADD SUBTRACT
%left DIVIDE MULTIPLY
%right LISTADD LISTSUBTRACT

%%
root:
				{ [] }
    | root rootstmt		{ [@{$_[1]}, $_[2]] }
    ;

rootstmt:
      DIRECTIVE exprlist RPAREN PERIOD			{ ['directive', substr($_[1], 1, -1), $_[2]->[1]] }
    | deflist PERIOD					{ $_[1] }
    ;

deflist:
      def			{ ['deflist', [$_[1]]] }
    | deflist SEMICOLON def	{ ['deflist', [@{$_[1]->[1]}, $_[3]]] }
    ;

def:
      INTCALL exprlist RPAREN RARROW stmtlist		{ ['def', substr($_[1], 0, -1), $_[2]->[1], $_[5]->[1]] }
    ;

stmtlist:
      stmt			{ ['stmtlist', [$_[1]]] }
    | stmtlist COMMA stmt	{ ['stmtlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

stmt:
      expr;

exprlist:
				{ ['exprlist', []] }
    | expr			{ ['exprlist', [$_[1]]] }
    | exprlist COMMA expr	{ ['exprlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

expr:
      ATOM			{ ['atom', $_[1]] }
    | INTEGER			{ ['integer', $_[1]] }
    | STRING			{ ['string', $_[1]] }
    | VARIABLE OPENRECORD ATOM  { ['variable-record-access', $_[1], $_[3]] }
    | VARIABLE newrecord	{ ['variable-record-update', $_[1], @{$_[2]}[1..2]] }
    | VARIABLE			{ ['variable', $_[1]] }
    | MACRO			{ ['macro', substr($_[1], 1)] }
    | list
    | tuple
    | case
    | fun
    | newrecord
    | binary
    | receive
    | expr DIVIDE expr		{ ['divide', $_[1], $_[3]] }
    | expr MULTIPLY expr	{ ['multiply', $_[1], $_[3]] }
    | expr ADD expr		{ ['add', $_[1], $_[3]] }
    | expr SUBTRACT expr	{ ['subtract', $_[1], $_[3]] }
    | expr EQUALS expr		{ ['equals', $_[1], $_[3]] }
    | expr LISTADD expr		{ ['list-add', $_[1], $_[3]] }
    | expr LISTSUBTRACT expr	{ ['list-subtract', $_[1], $_[3]] }
    | INTCALL exprlist RPAREN	{ ['intcall', substr($_[1], 0, -1), $_[2]->[1]] }
    | extcall
    | LPAREN expr RPAREN	{ $_[2] }
    ;

extcall:
      ATOM COLON INTCALL exprlist RPAREN	{ ['extcall', $_[1], substr($_[3], 0, -1), $_[4]->[1]] }
    | MACRO COLON INTCALL exprlist RPAREN	{ ['extcall-macro', substr($_[1], 1), substr($_[3], 0, -1), $_[4]->[1]] }
    | VARIABLE COLON INTCALL exprlist RPAREN	{ ['extcall-var', $_[1], substr($_[3], 0, -1), $_[4]->[1]] }
    ;

list:
      LISTOPEN exprlist LISTCLOSE	{ ['list', $_[2]->[1]] }
    ;

tuple:
      TUPLEOPEN exprlist TUPLECLOSE	{ ['tuple', $_[2]->[1]] }
    ;

case:
      KW_CASE expr KW_OF altlist KW_END	{ ['case', $_[2], $_[4]->[1]] }
    ;

altlist:
      alt			{ ['altlist', [$_[1]]] }
    | altlist SEMICOLON alt	{ ['altlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

alt:
      expr RARROW stmtlist	{ ['alt', $_[1], $_[3]->[1]] }
    ;

fun:
      KW_FUN LPAREN exprlist RPAREN RARROW stmtlist KW_END	{ ['fun-local', $_[3]->[1], $_[6]->[1]] }
    | KW_FUN ATOM COLON ATOM DIVIDE INTEGER			{ ['fun-ext', $_[2], $_[4], $_[6]] }
    | KW_FUN MACRO COLON ATOM DIVIDE INTEGER			{ ['fun-ext-macro', substr($_[2], 1), $_[4], $_[6]] }
    | KW_FUN VARIABLE COLON ATOM DIVIDE INTEGER			{ ['fun-ext-var', $_[2], $_[4], $_[6]] }
    | KW_FUN ATOM DIVIDE INTEGER				{ ['fun-int', $_[2], $_[4]] }
    ;

newrecord:
      OPENRECORD ATOM TUPLEOPEN exprlist TUPLECLOSE		{ ['record-new', $_[2], $_[4]->[1]] }
    ;

binary:
      OPENBINARY stmtlist CLOSEBINARY				{ ['binary', $_[2]->[1]] }
    ;

receive:
      KW_RECEIVE altlist after KW_END				{ ['receive', $_[2]->[1], $_[3]] }
    ;

# This is not a full node.
after:
								{ undef }
    | KW_AFTER expr RARROW exprlist				{ [$_[2], $_[4]->[1]] }
    ;
%%

=over 4

=item C<new>

Creates a new parser object. See L<Parse::Yapp> for more information.

=cut

1;

# vim: set sw=4 filetype=perl:
