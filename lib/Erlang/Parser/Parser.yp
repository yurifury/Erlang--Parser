# Copyright 2011 Anneli Cuss. ( anneli AT cpan DOT org )
# This is free software; you can redistribute it and/or modify it under the
# same terms as Perl itself.

%nonassoc EQUALS
%left ADD SUBTRACT
%left DIVIDE MULTIPLY

%%
root:
				{ [] }
    | root rootstmt		{ [@{$_[1]}, $_[2]] }
    ;

rootstmt:
      DIRECTIVE exprlist RPAREN PERIOD			{ ['directive', substr($_[1], 1, -1), $_[2]->[1]] }
    | INTCALL exprlist RPAREN RARROW stmtlist PERIOD	{ ['def', substr($_[1], 0, -1), $_[2]->[1], $_[5]->[1]] }
    ;

stmtlist:
      stmt			{ ['stmtlist', [$_[1]]] }
    | stmtlist COMMA stmt	{ ['stmtlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

stmt:
      expr;

exprlist:
				{ ['exprlist', []] }
    | expr			{ ['exprlist', [$_[1]]] }
    | exprlist COMMA expr	{ ['exprlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

expr:
      ATOM			{ ['atom', $_[1]] }
    | AATOM			{ ['atom', $_[1]] }
    | INTEGER			{ ['integer', $_[1]] }
    | STRING			{ ['string', $_[1]] }
    | VARIABLE OPENRECORD ATOM  { ['variable-record-access', $_[1], $_[3]] }
    | VARIABLE OPENRECORD AATOM { ['variable-record-access', $_[1], $_[3]] }
    | VARIABLE newrecord	{ ['variable-record-update', $_[1], @{$_[2]}[1..2]] }
    | VARIABLE			{ ['variable', $_[1]] }
    | MACRO			{ ['macro', substr($_[1], 1)] }
    | list
    | tuple
    | case
    | fun
    | newrecord
    | expr DIVIDE expr		{ ['divide', $_[1], $_[3]] }
    | expr MULTIPLY expr	{ ['multiply', $_[1], $_[3]] }
    | expr ADD expr		{ ['add', $_[1], $_[3]] }
    | expr SUBTRACT expr	{ ['subtract', $_[1], $_[3]] }
    | expr EQUALS expr		{ ['equals', $_[1], $_[3]] }
    | INTCALL exprlist RPAREN	{ ['intcall', substr($_[1], 0, -1), $_[2]->[1]] }
    | EXTCALL exprlist RPAREN	{ ['extcall', substr($_[1], 0, -1), $_[2]->[1]] }
    | LPAREN expr RPAREN	{ $_[2] }
    ;

list:
      LISTOPEN exprlist LISTCLOSE	{ ['list', $_[2]->[1]] }
    ;

tuple:
      TUPLEOPEN exprlist TUPLECLOSE	{ ['tuple', $_[2]->[1]] }
    ;

case:
      KW_CASE expr KW_OF altlist KW_END	{ ['case', $_[2], $_[4]->[1]] }
    ;

altlist:
      alt			{ ['altlist', [$_[1]]] }
    | altlist SEMICOLON alt	{ ['altlist', [@{$_[1]->[1]}, $_[3]]] }
    ;

alt:
      expr RARROW stmtlist	{ ['alt', $_[1], $_[3]->[1]] }
    ;

fun:
      KW_FUN LPAREN exprlist RPAREN RARROW stmtlist KW_END	{ ['fun-local', $_[3]->[1], $_[6]->[1]] }
    | KW_FUN EXTFUN						{ ['fun-ext', $_[2]] }
    | KW_FUN ATOM DIVIDE INTEGER				{ ['fun-int', $_[2], $_[4]] }
    | KW_FUN AATOM DIVIDE INTEGER				{ ['fun-int', $_[2], $_[4]] }
    ;

newrecord:
      OPENRECORD ATOM TUPLEOPEN exprlist TUPLECLOSE	{ ['record-new', $_[2], $_[4]->[1]] }
    | OPENRECORD AATOM TUPLEOPEN exprlist TUPLECLOSE	{ ['record-new', $_[2], $_[4]->[1]] }
    ;
%%

=over 4

=item C<new>

Creates a new parser object. See L<Parse::Yapp> for more information.

=cut

1;

# vim: set sw=4 filetype=perl:
