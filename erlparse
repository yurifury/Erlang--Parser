#!/usr/bin/env ruby
# This file is part of erlparse.
# Copyright 2011 Anneli Cuss
#
# erlparse is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# erlparse is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with erlparse.  If not, see <http://www.gnu.org/licenses/>.

$: << "./paxis"

require 'paxis'

class ASTNode
    def to_s; to_erlang end
    def inspect; to_erlang end
end

class ASTRoot < ASTNode
    def initialize(*stmts)
	@stmts = stmts
    end

    def to_erlang
	@stmts.map(&:to_erlang).join(".\n") + "."
    end

    attr_accessor :stmts
end

class ASTDirective < ASTNode
    def initialize(directive, val)
	@directive, @val = directive, val
    end

    def to_erlang
	"-#@directive(#@val)"
    end

    attr_accessor :directive
    attr_accessor :val
end

class ASTDefine < ASTNode
    def initialize(name, stmtlist)
	@name, @stmtlist = name, stmtlist
    end

    def to_erlang
	"#@name() ->\n" + @stmtlist.map {|s| "    " + s.to_erlang}.join(",\n")
    end

    attr_accessor :name
    attr_accessor :stmtlist
end

class HelperList
    def initialize(*stmts)
	@stmts = stmts
    end

    def to_erlang
	raise "HelperList #{inspect} found its way into reality"
    end

    def inspect; "HelperList(#{stmts.map(&:to_erlang).join(", ")})" end
    alias to_s inspect

    attr_accessor :stmts
end

class ASTImmAtom < ASTNode
    def initialize val
	@val = val
    end

    def to_erlang
	@val
    end

    attr_accessor :val
end

class ASTImmString < ASTNode
    def initialize val
	@val = val
    end

    def to_erlang
	@val.inspect # XXX
    end

    attr_accessor :val
end

class ASTImmInteger < ASTNode
    def initialize val
	@val = val
    end

    def to_erlang
	@val.to_s
    end

    attr_accessor :val
end

class ASTExtCall < ASTNode
    def initialize mod, fun, args
	@mod, @fun, @args = mod, fun, args
    end

    def to_erlang
	"#@mod:#@fun(#{@args.map(&:to_erlang).join(", ")})"
    end

    attr_accessor :mod
    attr_accessor :fun
    attr_accessor :args
end

class ASTImmList < ASTNode
    def initialize *items
	@items = items
    end

    def to_erlang
	"[" + @items.map(&:to_erlang).join(", ") + "]"
    end

    attr_accessor :items
end

class ASTBinOpDiv < ASTNode
    def initialize a, b
	@a, @b = a, b
    end

    def to_erlang
	"(#{a.to_erlang}) / (#{b.to_erlang})"
    end

    attr_accessor :a, :b
end

Erlang = Paxis.make do
    DIRECTIVE /-([a-z]+)\(/
    LPAREN /\(/
    RPAREN /\)/
    ATOM /[a-zA-Z_]+/
    PERIOD /\./
    INTCALL /([a-zA-Z_]+)\(/
    EXTCALL /([a-zA-Z_]+):([a-zA-Z_]+)\(/
    RARROW /->/
    STRING /"([^"]*)"/
    INTEGER /[0-9]+/
    WHITESPACE /[\n \t]+/
    COMMENT /%[^\n]*/
    COMMA /,/
    LISTOPEN /\[/
    LISTCLOSE /\]/
    DIV /\//

    ignore! WHITESPACE, COMMENT

    root(rootstmt) {ASTRoot.new rootstmt}
    root(root, root) {ASTRoot.new *(root_1.stmts + root_2.stmts)}
    rootstmt(DIRECTIVE, stmtlist, RPAREN, PERIOD) {
	ASTDirective.new DIRECTIVE[0], stmtlist.stmts
    }
    rootstmt(INTCALL, RPAREN, RARROW, stmtlist, PERIOD) {
	ASTDefine.new INTCALL[0], stmtlist.stmts
    }

    stmtlist(stmt) {HelperList.new stmt}
    stmtlist(stmtlist, COMMA, stmt) {
	HelperList.new *(stmtlist.stmts + [stmt])
    }

    stmt(call) {call}
    stmt(ATOM) {ASTImmAtom.new ATOM[0]}
    stmt(STRING) {ASTImmString.new STRING[0]}
    stmt(INTEGER) {ASTImmInteger.new INTEGER[0].to_i}
    stmt(list) {list}
    stmt(LPAREN, stmtlist, RPAREN) {stmtlist.stmts[0]}
    stmt(stmtlist, DIV, stmtlist) {
	ASTBinOpDiv.new stmtlist_1.stmts[0], stmtlist_2.stmts[0]
    }
    call(EXTCALL, stmtlist, RPAREN) {
	ASTExtCall.new EXTCALL[0], EXTCALL[1], stmtlist.stmts
    }
    list(LISTOPEN, stmtlist, LISTCLOSE) {ASTImmList.new *stmtlist.stmts}
end

inf = case ARGV[0]
      when "-"; STDIN.read
      else; File.read ARGV[0]
      end

outf = case ARGV[0]
       when "-"; STDOUT
       else; File.open ARGV[0].gsub(/\.erl$/, "") + ".cgrw"
       end

r = Erlang.pax!(inf)
puts r.to_erlang

outf.close

# vim: set sw=4 ts=8 noet cc=80:
