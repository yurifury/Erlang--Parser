#!/usr/bin/env ruby
# This file is part of erlparse.
# Copyright 2011 Anneli Cuss
#
# erlparse is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# erlparse is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with erlparse.  If not, see <http://www.gnu.org/licenses/>.

$: << "./paxis"

require 'paxis'

class ASTRoot
    def initialize(*stmts)
	@stmts = stmts
    end

    def to_erlang
	@stmts.map(&:to_erlang).join(".\n") + "."
    end

    attr_accessor :stmts
end

class ASTDirective
    def initialize(directive, val)
	@directive, @val = directive, val
    end

    def to_erlang
	"-#@directive(#@val)"
    end

    attr_accessor :directive
    attr_accessor :val
end

class ASTDefine
    def initialize(name, stmtlist)
	@name, @stmtlist = name, stmtlist
    end

    def to_erlang
	"#@name() ->\n" + @stmtlist.map {|s| "    " + s.to_erlang}.join(",\n")
    end

    attr_accessor :name
    attr_accessor :stmtlist
end

class ASTHelperList
    def initialize(*stmts)
	@stmts = stmts
    end

    def to_erlang
	raise "ASTHelperList #{inspect} found its way into reality"
    end

    attr_accessor :stmts
end

class ASTImmString
    def initialize val
	@val = val
    end

    def to_erlang
	@val.inspect # XXX
    end

    attr_accessor :val
end

class ASTImmInteger
    def initialize val
	@val = val
    end

    def to_erlang
	@val.to_s
    end

    attr_accessor :val
end

class ASTExtCall
    def initialize mod, fun, args
	@mod, @fun, @args = mod, fun, args
    end

    def to_erlang
	"#@mod:#@fun(#{@args.map(&:to_erlang).join(", ")})"
    end

    attr_accessor :mod
    attr_accessor :fun
    attr_accessor :args
end

class ASTImmList
    def initialize *items
	@items = items
    end

    def to_erlang
	"[" + @items.map(&:to_erlang).join(", ") + "]"
    end

    attr_accessor :items
end

Erlang = Paxis.make do
    DIRECTIVE /-([a-z]+)\(/
    RPAREN /\)/
    ATOM /[a-zA-Z_]+/
    PERIOD /\./
    INTCALL /([a-zA-Z_]+)\(/
    EXTCALL /([a-zA-Z_]+):([a-zA-Z_]+)\(/
    RARROW /->/
    STRING /"([^"]*)"/
    INTEGER /[0-9]+/
    WHITESPACE /[\n \t]+/
    COMMA /,/
    LISTOPEN /\[/
    LISTCLOSE /\]/

    root(rootstmt) {ASTRoot.new rootstmt}
    root(root, root) {ASTRoot.new *(root_1.stmts + root_2.stmts)}
    rootstmt(DIRECTIVE, ATOM, RPAREN, PERIOD) {
	ASTDirective.new DIRECTIVE[0], ATOM[0]
    }
    rootstmt(INTCALL, RPAREN, RARROW, stmtlist, PERIOD) {
	ASTDefine.new INTCALL[0], stmtlist.stmts
    }

    stmtlist(stmt) {ASTHelperList.new stmt}
    stmtlist(stmtlist, COMMA, stmt) {
	ASTHelperList.new *(stmtlist.stmts + [stmt])
    }
    stmt(call) {call}
    stmt(STRING) {ASTImmString.new STRING[0]}
    stmt(INTEGER) {ASTImmInteger.new INTEGER[0].to_i}
    stmt(list) {list}
    call(EXTCALL, stmtlist, RPAREN) {
	ASTExtCall.new EXTCALL[0], EXTCALL[1], stmtlist.stmts
    }
    list(LISTOPEN, stmtlist, LISTCLOSE) {ASTImmList.new *stmtlist.stmts}
end

inf = case ARGV[0]
      when "-"; STDIN.read
      else; File.read ARGV[0]
      end

outf = case ARGV[0]
       when "-"; STDOUT
       else; File.open ARGV[0].gsub(/\.erl$/, "") + ".cgrw"
       end

r = Erlang.start(inf)[0][1]
puts r.to_erlang

outf.close

# vim: set sw=4 ts=8 noet cc=80:
